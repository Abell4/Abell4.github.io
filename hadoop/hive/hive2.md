# hive 
## 数据查询:

- [dfdf](https://camo.githubusercontent.com/4301f161d42f1fd31da86aa1d4e13085f99ac8e1/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31343436363537372d616662623662313333343834303262312e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

	- where,having,group by;
		- 1 使用分组就不再逐行执行模式了，会根据我们的分组key以分组模式执行，
			一旦有group by子句，那么，在select子句中就不能有 （分组字段，聚合函数） 以外的字段
		- 2 使用聚合函数得到的结果默认的字段名不好使，我们要进行调用可以给它取一个别名，就可以在条件中使用了，
			同一层给having使用，作为子查询时可以给外层where用
		- 3 where 执行时间在聚合之前进行数据筛选，而having是在聚合结束之后继续条件处理
	- 排序区别:
		- order by: 全局排序，一个reduce
		- sort by: 不是全局，进入reducer之前排序完成；设置mapred.reduce.tasks>1
		- distribute by：开启的reducer数量=桶数
		- cluster by:当分桶和sort by 字段是同一个时，相当于distribute by+sort by;不是同一个的话，不适用
	- join on:
		- 内连接：inner join
		- 右外连接：right join
		- 左外连接：left join
		- 全连接：full join
		- 左半连接：left semi join(相当于join连接两个表后产生的数据中的左半部分)
	- in 关键字
		- 效果等同于 left semi join
			- eg : select* from 表名 where id in (select ID from表2);
	
## 数据类型:
	- 原子数据类型
		- 数值型  .  时间型  . 布尔型  .  字符串型
	- 复杂数据类型:
		- 数组: 相同数据类型的元素组成,可以通过下标访问,从0开始
		- 映射(map):通过key来访问元素
		
- [faa](https://camo.githubusercontent.com/0b6125cf1b123cd29d1b98671680248488a4e9c7/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31343436363537372d336333303133613330333434613663392e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)	
	
		- 结构体(struct):可以包含不同类型的元素
		
- [asdf](https://camo.githubusercontent.com/317696021a95f9c285ba6d2589f0663c69befa1a/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31343436363537372d643939353330626361313230393766642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)	
	
## 函数使用:
	- 内置函数: